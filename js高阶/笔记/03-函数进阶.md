# 一、函数的定义

- **自定义函数（命名函数）**

  ```js
  function fn() {};
  ```

- **函数表达式（匿名函数）**

  ```js
  var fun = function() {};
  ```

- **new Function ( '参数1' , '参数2' , '参数3' ) ;**

  ```js
  var f = new Function('a','b','console.log(a + b)');	// 语句直接用字符串的形式输出
  f(1,2);  // 传实参
  ```

  - **所有的函数都是Function的实例（对象）**

# 二、函数的调用

1. 普通函数  **<font color='red'>*this指向 window*</font>**

   ```js
   function fn() {
       console.log('hi');
   }
   window.fn();
   fn.call();
   ```

2. 对象的方法  **<font color='red'>*this指向对象 o*</font>**

   ```js
   var o = {
       sayHi: function() {
           console.log('hi');
       }
   }
   o.sayHi();
   ```

3. 构造函数  **<font color='red'>*this指向实例对象 cy ，原型对象（ Star.prototype.sing）里面的 this也指向 cy这个实例对象*</font>** 

   ```js
   functoin Star() {
       console.log('hi');
   }
   var cy = new Star();
   ```

4. 绑定事件函数 **<font color='red'>*this指向调用者 btn*</font>** 

   ```js
   btn.onclick = function() {
       console.log('hi');
   }
   ```

5. 定时器函数 **<font color='red'>*this指向 window*</font>** 

   ```js
   window.setInterval(function() {
        console.log('hi');
   },1000)
   ```

6. 立即执行函数 -->自动调用 **<font color='red'>*this指向 window*</font>** 

   ```js
   (function() {
        console.log('hi');
   })()
   ```

   ![img](file://E:/EPI/js%E9%AB%98%E9%98%B6/%E3%80%9010%E3%80%91JavaScript%E9%AB%98%E7%BA%A7%EF%BC%88%E5%90%ABES6%EF%BC%89/JavaScript%20%E9%AB%98%E7%BA%A7_day03/4-%E7%AC%94%E8%AE%B0/images/img1.png?lastModify=1605613905)

## 1. 改变函数内部指向

### 1). call

```js
fun.call (thisArg, arg1, arg2, ...)
```

- 调用函数
- 改变函数内部 **this指向** 

```js
        var o = {
            name: 'Andy'
        }
        function fn(a,b) {
            console.log(this);	// {name:"Andy"}
            console.log(a+b);	// 3
        }
        fn.call(o, 1, 2);
```

- 继承

```js

		function Father(uname, age){
            this.uname = uname;
            this.age = age;
        }
        function Son(uname, age, score){
            // 调用父构造函数 把父构造函数里面的this改成子构造函数的this
            Father.call(this, uname, age);
            this.score = score;
        }
        var six = new Son('春杨', 21, 100);
        console.log(six);
        //Son {uname: "春杨", age: 21}
        //age: 21
        //uname: "春杨"
        //__proto__: Object
```

### 2). apply

```js
fun.apply(this.Arg, [argArry])
```

- 必须以**数组**的形式传递

- 调用函数
- 改变函数内部 **this指向** 
- 借助数学内置对象

```js
        var o = {
            name: 'Andy'
        }
        function fn(arr) {
            console.log(this);  // {name: "Andy"}
            console.log(arr);   // pink
        }
        fn.apply(o,['pink']);

        var arr = [6,7,3,8];
        var max = Math.max.apply(Math, arr);
        console.log(max);	// 8
```

### 3). bind

```js
fun.bind (thisArg, arg1, arg2, ...)
```

- 改变函数内部 **this指向** 

**<font color='red'>*只绑定 不调用*</font>** 

```js
        var o = {
            name: 'Andy'
        }
        function fn(arr) {
            console.log(this);
        }
        var f = fn.bind(o); // 只绑定 不调用
        f();
```

```js
    <button>点击</button>
    <button>点击</button>
    <button>点击</button>
    <script>
        // 有一个按钮,当我们点击了之后,就禁用这个按钮,3秒钟之后开启这个按钮
/*      var btn = document.querySelector('button');
        btn.onclick = function() {
            this.disabled = true;
            setTimeout(function() {
            this.disabled = false;
        }.bind(this), 1000)
        } */

        var btn = document.querySelectorAll('button');
        for(var i = 0; i < btn.length; i++) {
            btn[i].onclick = function() {
                this.disabled = true;
                setTimeout(function() {
                this.disabled = false;
                }.bind(this), 1000)
            }
        }
        
</script>    
```


```js
	<button>点击</button>
    <button>点击</button>
    <button>点击</button>
    <script>
        // 有一个按钮,当我们点击了之后,就禁用这个按钮,3秒钟之后开启这个按钮
        
		/*      
		var btn = document.querySelector('button');
        btn.onclick = function() {
            this.disabled = true;
            setTimeout(function() {
            this.disabled = false;
        }.bind(this), 1000)
        } */

        var btn = document.querySelectorAll('button');
        for(var i = 0; i < btn.length; i++) {
            btn[i].onclick = function() {
                this.disabled = true;
                setTimeout(function() {
                this.disabled = false;
                }.bind(this), 1000)
            }
        }
        
</script>
```

# 三、严格模式  <font color='red'>`use strict`</font>

## 1. 为脚本开启严格模式 

```js
<script> 
  (function (){
    "use strict";        
	})(); 
</script> 
```

以将整个脚本文件 放在一个立即执行的匿名函数之中。这样<font color='red'>独立创建一个作用域</font>而不影响其他 script 脚本文件。 

## 2. 为函数开启严格模式 

```js
function fn(){
    "use strict";   
    return "这是严格模式。"; 
} 
```

给某一个函数开启了严格模式。

## 3. 严格模式中的变化 

### 1). 变量

- 变量都必须先用 **var** 命令声明。

- **严禁删除已经声明变量**。例如，`delete x; `语法是错误的。 

### 2).  this 指向问题 

|                                  | 以前                                              | 严格模式                                        |
| :------------------------------: | ------------------------------------------------- | ----------------------------------------------- |
| 全局作用域函数中的 this 指向对象 | window                                            | undefined                                       |
|             构造函数             | 不加`new`也可以 调用,当普通函数，this指向全局对象 | 不加new调用, this 指向的是undefined，赋值会报错 |
|                                  |                                                   | new 实例化的构造函数指向创建的对象实例          |
|                                  |                                                   | 定时器 this 还是指向 window                     |
|                                  |                                                   | 事件、对象还是指向调用者                        |

```js
function Star() {
     this.sex = '男';
 }
 var ldh = new Star();
 console.log(ldh.sex);
```

### 3). 函数 

- 函数不能有**重名的参数**。 
- 函数必须声明在**顶层**。
- 不允许在非函数的代码块内声明函数。 

# 四、高阶函数

**对其他函数进行操作，它<font color='red'>接收函数作为参数</font>或<font color='red'>将函数作为返回值输出</font>。** 

```js
        function fn(a, b, callback) {
            console.log(a + b);
            callback && callback();
        }
        fn(1, 2, function() {
            console.log('我是最后调用的');
        });

        $("div").animate({
            left: 500
        }, function() {
            $("div").css("backgroundColor", "purple");
        })
```

# 五、闭包

## 1. 变量作用域

- 分为<font color='red'>**全局变量**</font>和<font color='red'>**局部变量**</font>
  - 函数内部可以使用全局变量。 
  - 函数外部不可以使用局部变量。 
  - 当函数执行完毕，本作用域内的局部变量会销毁。 

## 2. 闭包

一个作用域可以访问**另外一个函数内部的局部变量**。 

```js
        function fn() {
            var num = 10;
            function fun() {
                console.log(num);
            }
            fun();
        }
        fn();
		// fun 这个函数作用域 访问了 另外一个函数fn 里面的局部变量 num
```







